overwriting docs:
doc.overwrite() then doc.save() OR Model.replaceOne()

Finding a Subdocument
Each subdocument has an _id by default. Mongoose document arrays have a special id method for searching a document array to find a document with a given _id.
const doc = parent.children.id(_id);

You can also create a subdocument without adding it to an array by using the create() method of Document Arrays.
const newdoc = parent.children.create({ name: 'Aaron' });

Removing Subdocs
Each subdocument has its own remove method. For an array subdocument, this is equivalent to calling .pull() on the subdocument. For a single nested subdocument, remove() is equivalent to setting the subdocument to null.
// Equivalent to `parent.children.pull(_id)`
parent.children.id(_id).remove();
(MUST SAVE AFTER)

PARENTS OF SUBDOCS:
doc.singleNested.parent() === doc; // true
doc.docArr[0].parent() === doc; // true

findOneAndUpdate():
Returns the document _before_ `update` was applied
You should set the new option to true to return the document after update was applied.
As an alternative to the new option, you can also use the returnOriginal option. returnOriginal: false is equivalent to new: true

if i do not need to save after querying a document, use lean!

Update validators are off by default - you need to specify the runValidators option.
To turn on update validators, set the runValidators option for update(), updateOne(), updateMany(), or findOneAndUpdate(). 
!!! Be careful: update validators are off by default because they have several caveats. !!!

If any pre hook errors out, mongoose will not execute subsequent middleware or the hooked function.

You can pass options to Schema.pre() and Schema.post() to switch whether Mongoose calls your remove() hook for Document.remove() or Model.remove(). 
Note here that you need to set both document and query properties in the passed object:
// Only document middleware
schema.pre('remove', { document: true, query: false }, function() {
  console.log('Removing doc!');
});
// Only query middleware. This will get called when you do `Model.remove()`
// but not `doc.remove()`.
schema.pre('remove', { query: true, document: false }, function() {
  console.log('Removing!');
});

KELL-E a query:true ?? vagy az true alapból???

{ document: true, query: false }: minden hooknál fontos!!!

ERROR HANDLING: on every pre and post hook!
// Handler **must** take 3 parameters: the error that occurred, the document
// in question, and the `next()` function
schema.post('save', function(error, doc, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    next(new Error('There was a duplicate key error'));
  } else {
    next();
  }
});

We can depopulate a populated field:
story.depopulate('author'); // maybe this will be useful

populate options:
limit
perDocumentLimit

pupulate can be used on documents as well (not just queries/models)

Populate in Middleware
You can populate in either pre or post hooks. If you want to always populate a certain field, check out the mongoose-autopopulate plugin.
// Always attach `populate()` to `find()` calls
MySchema.pre('find', function() {
  this.populate('user');
});
Maybe this is useful when removing dependent documents?

-----what i want-----:
DONE validation with joi
always validating when database/model/document/anything persistent changes
DONE removing dependent documents
NO NEED creating dependent documents?
editing dependent documents?
easily creating documents(e.g. not providing secret and public ids, let it generate for itself)
autogenerating fields with functions
solve pagination

only requirement validators in mongoose schema, everything else in joi validators!

3 TYPES OF VALIDATION:
1. REQUIREMENT
2. STATIC
3. NEEDS DB QUERY 

!!!  consider {immutable: true} property everywhere. (e.g. public and secret id)

timestamps is not a valid option for a field in Mongoose. It is only a valid option for the entire schema !!!!!

required
	should set: mongoose + joi
	auto generated synchronously: mongoose+joi
	auto generated asynchronously: only joi
static independent rule
	only joi
static dependent rule
    mongoose + joi
needs db query
	pre save hook (and possibly other hooks)

REQUIRED
DEFAULT
VALIDATE

// 'unique' and 'index' should not be in the same field
// 'unique' and 'sparse' index should only be present at the same time if the field is not required

async default values should be generated only at CREATION.
this means:

compound unique indexes??
(egy termék-bíra pároshoz csak egy bírálat tartozhat)

IMPORTANT: METHOD NAME CAN BE AN ARRAY!
toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {
    console.log(this.getFilter());
  });
  
NEXT STEP: implementing a chain.

szóval végülis a pre('validate') ben kell generálni az async default mezőket.

//////
app.use(passport.session());
is actually the same as:

app.use(passport.authenticate('session'));


// 1. APP LEVEL express.urlencoded(): http query-style body => req.body
// 2. APP LEVEL express.json(): http json body => req.body
    
// 3. AUTH LEVEL passport.initialize(). sets methods: req.login, req.logout, req.isauthenticated, req.isunauthenticated, req.passport
// 4. AUTH LEVEL authentication. what this only does: checks if req.user field is present (true or false) (CHECKAUTHENTICATED)

// 5. REQ LEVEL request validation. with joi. sends proper error messages. because we dont validate req.user, maybe this can go
// even more back, maybe before passport.initialize()?
// i think that validation should be before authentication. because it is not the validations job to check if a user is
// present on the request, since this is a global task rather than request dependent, and even if validation would be after
// the authentication, it would mean that the user presence is checked twice in a row which is a waste of resource
// and duplicate behaviour
// at this point the request is prepared. (what prepared means: every context is present and valid. context means ...)
// this should say: "bad request", i mean no other information should be displayed to the client about what was wrong
// validation = the request should be in a form that can be passed to a model constructor or query object
// without getting any errors. BUT: we can have errors AFTER the model/query validation.
// but the truth is: for reading data, the request itself is enough to validate.
// THIS statement is only for get requests (c_R_ud)

// 6. REQ LEVEL authorization: in the http header jwt, there will be the user(name/id idk yet), and the role of the user.
// this middleware will check that role and possibly other things. for now, this will be after validation
// WHY: because the structure of the request may determine if the user is authorized for the operation or not.
// is this good? idk.
// AUTHORIZATION SHOULD DO SOME KIND OF SANITIZATION AS WELL, TO MEET THE CURRENT ROLE'S PERMISSIONS

// 7. REQ LEVEL getting data from db
// 8. REQ LEVEL sending data back to the client

// X. APP LEVEL express-session. http header (session cookie) => get session data from db => req.session
// X. APP LEVEL cookie parser. http header => req.cookies (maybe for refresh tokens)
// X. AUTH LEVEL and passport.session(). req.session => session_id-ből db alapján megkeresi a usert => req.user
// I WILL ONLY SET COOKIE-PARSER OR EXPRESS-SESSION IF I RUN INTO AN ERROR THAT IS UNSOLVABLE WITHOUT IT


we know that the request is syntactically correct.
validate:   is there anything that SHOULD BE on the request but it IS NOT? (fatal)
            answer: 400 or next() SURE
            is there anything that SHOULD NOT BE on the request but it IS? (not fatal)
            answer: next()
val-sanitize:   is there anything that SHOULD BE on the filter but IS NOT on the request?
            answer: 400 or next() SURE
                is there anything that SHOULD NOT BE on the filter but it IS on the request?
            answer: next()
authorize:  is this request even allowed for the role?
            answer: 403/404 or next()
            is there anything that SHOULD BE on the request based on the role but is NOT?
            answer: 400 or next()
            is there anything that SHOULD NOT BE on the request based on the role but it IS?
            answer: 
auth-sanitize:  is there anything that SHOULD BE on the filter based on the role but it IS NOT on the request?
                answer: 400 or next()
                is there anything that SHOULD NOT BE on the filter based on the role but it IS on the request?
                answer: sanitize then next()

//      we know that the request is syntactically correct.
//          validate:   
//          
                //HANDLED WITH JOI
//              is there anything that SHOULD BE on the request (role-independent) but it IS NOT? 
//              i mean something that cant be defaulted.
//                  answer: 400 or next() 
//              THIS CASE: do nothing, because an empty request is okay (/api/a/product/m)
//
                // not handled currently, but in the future there may be forbidden fields.
                // i dont want to give false results for the user.
                // there should be forbidden fields in authorization mw. 
//              is there anything that SHOULD NOT BE on the request but it IS? maybe will be relevant at put/post
//                  answer: this is not a problem, so next()
//              THIS CASE: 
//
//          validate-sanitize:   
//              add role-independent fields to filter, sort, pagination, etc.
//
//              is there anything that SHOULD BE on the filter (role-independent) but IS NOT on the request?
//                  answer: can i put a default value?
//                      yes -> put it there, next()
//                      no -> 400 or next() SURE
//
//              is there anything that SHOULD NOT BE on the filter but it IS on the request?
//                  answer: next()
//
// I dont care about the above. in this mw, first joi validation. no actions, just checking
// then there should be an auth middleware that only checks authorization. no actions, just checking.
// then there should be a mw to prepare the query.
// we should never care about additional query params. additionally build the filter and sort and pagination params.

res.locals.filter = {
    competition_id: '', // default: current
    manufacturer_id: '', 
    public_id: '',
    secret_id: '',
    product_name: '',
    factory_name: '',
    maturation_time_type: '',
    maturation_time_quantity: '',
    maturation_time_unit: '',
    milk_type: '',
    product_category_list: '',
    product_description: '',
    approved: '',
    approval_type: '',
    handed_in: ''
}

res.locals.sort_by = ''
res.locals.sort_order = ''
res.locals.page = ''
res.locals.page_size = ''

// validating req.query
// we don't need to.

// validating req.body
// we don't need to.

// and the only remaining question: cookies.

// we get a request that is one request (req)

// it has a req.user. i should validate req.user. but not here.
// it can have query params
// it can have cookies in its headers

// it can have a body: we dont care.
// it has as header with a jwt in it: we dont care.


// + PAGE NUMBER (1-...)
// + HOW MANY ITEMS ON ONE PAGE (1-...)

/*competition_id: {
    type: ObjectId,
    ref: Competition_Model,
    index: true,
},
manufacturer_id: {
    type: ObjectId,
    ref: User_Model,
    index: true,
},
public_id: {
    type: String,
    unique: true,
},
secret_id: {
    type: String,
    unique: true,
},
product_name: {
    type: String,
    index: true,
},
factory_name: {
    type: String,
    index: true,
},
maturation_time_type: {
    type: String,
    index: true,
},
maturation_time_quantity: {
    type: Number,
},
maturation_time_unit: {
    type: String,
},
milk_type: {
    type: String,
    index: true,
},
product_category_list: {
    type: [{
        type: String,
    }],
    index: true,
},
product_description: {
    type: String,
},
approved: {
    type: Boolean,
    index: true,
    default: false,
},
approval_type: {
    type: String,
    index: true,
},
handed_in: {
    type: Boolean,
    index: true,
    default: false,
}*/