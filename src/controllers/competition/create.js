// ORGANIZER, SERVER
module.exports = async (body, user, parent_session) => {

    // 1. Validate body
    const create_competition_validator = require('../../validators/requests/api/competition/create')
    try {
        await create_competition_validator.validateAsync(body)
    } catch (err) {
        return { code: 400, data: err.details }
    }

    // 2. Arrayize
    body = Array.isArray(body) ? body : [body]

    // 3. Authorize create
    const authorizer = require('../../authorizers/competition')
    try {
        body = body.map((competition) => authorizer(competition, 'create', user))
    } catch (reason) {
        return {
            code: 403,
            data: reason
        }
    }

    // 4. Start session and transaction if they don't exist
    const Competition_Model = require('../../models/Competition')
    const session = parent_session ?? await Competition_Model.db.startSession()
    if (!session.inTransaction()) session.startTransaction()

    // 5. Create locally
    const fs_promises = require('fs').promises
    const default_product_category_tree = require('../../static/product_category_tree.json')
    const default_certificate_template_buffer = await fs_promises.readFile(
        '../../static/default_certificate_template.docx'
    )
    const default_certificate_template = {
        name: 'default_certificate_template.docx',
        mimetype:
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        buffer: default_certificate_template_buffer,
        size: default_certificate_template_buffer.length,
    }

    const now = Date.now

    const _competitions = body.map((competition) => ({
        ...competition,
        creation_date: now, // just to match the other dates.
        ...(competition.entry_opened && { last_entry_open_date: now }),
        // last_entry_close_date will be undefined
        ...(competition.competition_opened && {
            last_competition_open_date: now,
        }),
        // last_competition_close_date will be undefined
        // archived will be generated by model
        // archival_date will be undefined
        // payment_needed, association_members_need_to_pay, entry_fee_amount, entry_fee_currency is OK
        ...(!(competition.product_category_tree ?? false) && {
            product_category_tree: default_product_category_tree,
        }),
        ...(!(competition.certificate_template ?? false) && {
            certificate_template: default_certificate_template,
        }),
        // ignore_extreme_values will be false if undefined
    }))
    const competitions = _competitions.map((competition) => new Competition_Model(competition))

    // 6. Validate created documents
    const competition_validator = require('../../validators/schemas/Competition')
    try {
        const validator_promises = competitions.map((competition) =>
            competition_validator.validateAsync(competition)
        )
        await Promise.all(validator_promises)
    } catch (err) {
        if (!parent_session) {
            if (session.inTransaction()) await session.abortTransaction()
            await session.endSession()
        }
        return { code: 400, data: err.details }
    }

    // 7. Check dependencies: Ask all dependencies if this creation is possible.
    const dependencies = []
    const dependency_approvers = dependencies.map(dependency => require(`../${dependency}/approve_dependent_mutation/competition`))

    const dependency_approver_promises = []
    for (const dependency_approver of dependency_approvers) {
        dependency_approver_promises.push(dependency_approver(competitions.map(competition => ({ old: null, new: competition })), user, session))
    }
    const dependency_approver_results = await Promise.all(dependency_approver_promises)

    const unapproved = dependency_approver_results.find(dependency_approver_result => !dependency_approver_result.approved)
    if (unapproved) {
        if (!parent_session) {
            if (session.inTransaction()) await session.abortTransaction()
            await session.endSession()
        }
        return {
            code: 403,
            data: unapproved.reason
        }
    }

    // 8. Check collection integrity
    // We can not have a better validation for certificate template, since none of its contents is strictly required.
    // No need to check for any uniqueness.
    // TODO: this should be at validation
    //for (const competition of competitions) {
    //    // product_category_tree needs to be a subtree of the default tree.
    //    if (!is_subtree(competition.product_category_tree, default_product_category_tree)) {
    //        if (!parent_session) {
    //            if (session.inTransaction()) await session.abortTransaction()
    //            await session.endSession()
    //        }
    //        return {
    //            code: 403,
    //            data: 'product_category_tree_needs_to_be_a_subtree_of_the_default_product_category_tree',
    //        }
    //    }
    //}

    // 9. Save created documents
    await Competition_Model.bulkSave(competitions, { session: session })

    // 10. Update dependents
    // Nothing needs to be updated.

    // 11. Commit transaction and end session.
    if (!parent_session) {
        if (session.inTransaction()) await session.commitTransaction()
        await session.endSession()
    }

    // 12. Reply
    return {
        code: 201,
        data: undefined, // TODO: check if it works if i leave it out, etc.
    }
}
